#!/usr/bin/swipl
%Creation of a test-tree :
%                a
%								 |
%								 3
%             /  |  \
%           b    c    d
%					 |     |     |
%					 2     1     3
%         /|\   /|\   /|\
%        e f g h i j k l m
%			   | | | | | | | | |
%				 4 3 2 7 1 4 3 5 3


branch(a,b).
branch(a,c).
branch(a,d).
branch(b,e).
branch(b,f).
branch(b,g).
branch(c,h).
branch(c,i).
branch(c,j).
branch(d,k).
branch(d,l).
branch(d,m).

val(N,e):-N is 4.
val(N,f):-N is 3.
val(N,g):-N is 2.
val(N,h):-N is 7.
val(N,i):-N is 1.
val(N,j):-N is 4.
val(N,k):-N is 3.
val(N,l):-N is 5.
val(N,m):-N is 3.

%Rules to define minimum of a number-list :
min([A],A).
min([A|B],R):-min(B,S),R is min(A,S).

%Rules defining min of a list of sublists, each one formed by two elements, the first being a number :
%Those are used in the first minmax iteration (choice), where we wanna discover the best move, and not
%the best score.
minM([A,B],[C,_],[A,B]):-A<C.
minM([A,_],[C,D],[C,D]):-A>=C.
minM([[A,B]],[A,B]).
minM([[A,B]|C],[RA,RB]):-minM(C,S),minM([A,B],S,[RA,RB]).

%By encapsulating branch(),minimax() with evalChild(), we can use setof to create list of scores of all 
%children verifying minmax(). We will then be able to find the minimum score amongst it, using the rule min()
%previously defined. 
evalChild(Node,Score,Level):-branch(Node,Child),minimax(Child,Score,Level).

%Once the max recursion level is reached we evaluate the the leaves.
minimax(Leaf,Score,0):-val(Score,Leaf).
%While the recursion level has not been reached, keep on building the tree. The min/max alternance is acheived
%by switching the Score sign at each iteration and always calculating the minimum (Thanx wikipedia).
minimax(Node,Score,Level):-NewLev is Level-1,setof(A,evalChild(Node,A,NewLev),ScoreList),
													min(ScoreList,NewScore),Score is -NewScore.

%First predicate to evaluate, this is cut from the algorithm body to allow us to get the best move, and not
%its score as we would have obtained by calling directly minimax().
evalMove(Game,Move,MoveScore,Level):-branch(Game,Move),minimax(Move,MoveScore,Level).
choice(Game,Move,Level):-NewLev is Level-1,setof([MoveScore,Move],evalMove(Game,Move,MoveScore,NewLev),List),
												write(List),minM(List,[_,Move]).

%This algorithm may prove wrong when used with a odd heuristic (in this case we can only test 2).

%----------------------------------------------------------------------------------------

%Modelisation of a game state and of an eval function for a game :

%Regarde si la grille S peut être le tour suivant de la grille L avec l’ajout de P (rond ou croix). C est le 
%compteur qui correspond à la dernière pièce ajoutée (va de 1 à 5)

% Fonction outils

% nieme(N,X,Y) est vrai si Y est le nième element de la liste X
nieme(1, [H|_], H).
nieme(N, [_|T], Z) :-
N > 0,
N1 is N - 1,
nieme(N1, T, Z).
%rang(N,Y,X) est vrai si N est le rang de l'élément X dans la liste Y
rang(0,X,[X|_]).
rang(N,X,[_|LB]) :- var(N),rang(M,X,LB),N is M+1.
rang(N,X,[_|LB]) :- nonvar(N),M is N-1,rang(M,X,LB).

% On encapsule nieme pour corriger le fait que C soit < 0
niemec(N,X,Y):-N == 0,nieme(5,X,Y).
niemec(N,X,Y):-N == -1,nieme(4,X,Y).
niemec(N,X,Y):-N == -2,nieme(3,X,Y).
niemec(N,X,Y):-N == -3,nieme(2,X,Y).
niemec(N,X,Y):-(N > 0),nieme(N,X,Y).
% pour rang on aura :
rangc(N,Y,X):-N=<0,-N=<5,M is 5+N,rang(M,Y,X).
rangc(N,Y,X):-N>0,rang(N,Y,X).
% Jeux = [11,22,32,51,92].

%desc([L1,L2,L3,L4,L5,LP,LC],[S1,S2,S3,S4,S5,SP,SC]):-
%SC is (LC+1) mod 5,
%(LP == 2, SP is 1);(LP == 1, SP is 2),
%R1 is C - 1, niemec(R1,[L1,L2,L3,L4,L5],A1),niemec(R1,[S1,S2,S3,S4,S5],A1),
%R2 is C - 2, niemec(R2,[L1,L2,L3,L4,L5],A2),niemec(R2,[S1,S2,S3,S4,S5],A2),
%R3 is C - 3, niemec(R3,[L1,L2,L3,L4,L5],A3),niemec(R3,[S1,S2,S3,S4,S5],A3),
%R4 is C - 4, niemec(R4,[L1,L2,L3,L4,L5],A4),niemec(R4,[S1,S2,S3,S4,S5],A4),
%niemec(LC,[S1,S2,S3,S4,S5],V), between(0,90,V), SP is V mod 10.

desc([L1,L2,L3,L4,L5,P,C],[S1,S2,S3,S4,S5,SP,SC]):-
SC is (C+1) mod 5,
((P == 2, SP is 1);(P == 1, SP is 2)),
R1 is C - 1, niemec(R1,[L1,L2,L3,L4,L5],A1),niemec(R1,[S1,S2,S3,S4,S5],A1),
R2 is C - 2, niemec(R2,[L1,L2,L3,L4,L5],A2),niemec(R2,[S1,S2,S3,S4,S5],A2),
R3 is C - 3, niemec(R3,[L1,L2,L3,L4,L5],A3),niemec(R3,[S1,S2,S3,S4,S5],A3),
R4 is C - 4, niemec(R4,[L1,L2,L3,L4,L5],A4),niemec(R4,[S1,S2,S3,S4,S5],A4),
niemec(C,[S1,S2,S3,S4,S5],V), between(0,90,V), P is V mod 10,
V1 is S1 // 10, V2 is S2 // 10, V3 is S3 // 10, V4 is S4 // 10, V5 is S5 // 10, 
not(V1 == V2), not(V1 == V3),not(V1 == V4), not(V1 == V5),not(V2 == V3),
not(V2 == V4),not(V2 == V5), not(V3 == V4),not(V3 == V5), not(V4 == V5).

%Evaluation function:
%Let 0 stand for an unused area
%Let 1 stand for the computer symbol
%Let 2 stand for the user symbol

eval(Score,Game):-win(Game),Score is 100,!.		%If "Game" is a winning move, Score is maximum
eval(Score,Game):-lose(Game),Score is -100,!.	%If "Game" is a losing move, Score is minimum
eval(Score,Game):-count(Game,MT,1,2),count(Game,HT,2,2),Score is MT*10-HT*10.

win(Game):-count(Game,NT,1,3),write(NT),NT<0.
lose(Game):-count(Game,NT,2,3),NT>0.

%count(Game,NT,Player,N) is true when NT is the number of lines/columns/diags where player "Player" has N marks
count(Game,NT,Player,N):- (setof(X,line(Game,Player,X,N),NbL),length(NbL,L);L is 0),!,
											(setof(Y,column(Game,Player,Y,N),NbC),length(NbC,C);C is 0),!,
											(setof(Z,diag(Game,Player,Z,N),NbD),length(NbD,D);D is 0),!,
											NT is (L+C+D).
%line(Game,Player,X,N) is true if the player has N marks on line X
%same for column and diag
line([],_,_,N):-N is 0.
line([First|Game],Player,X,N):-between(0,2,X),A is First mod 10, B is First//30,
															A==Player, B==X, line(Game,Player,X,M),N is M+1.
line([First|Game],Player,X,N):-between(0,2,X),A is First mod 10,not(A==Player),line(Game,Player,X,N).
line([First|Game],Player,X,N):-between(0,2,X),B is First//30,not(B==X),line(Game,Player,X,N).

column([],_,_,N):-N is 0.
column([First|Game],Player,Y,N):-between(0,2,Y),A is First mod 10, B is (First//10) mod 3,
															A==Player, B==Y, column(Game,Player,Y,M),N is M+1.
column([First|Game],Player,Y,N):-between(0,2,Y),A is First mod 10,not(A==Player),column(Game,Player,Y,N).
column([First|Game],Player,Y,N):-between(0,2,Y),B is (First//10) mod 3,not(B==Y),column(Game,Player,Y,N).

diag([],_,_,N):-N is 0.
diag([First|Game],Player,Z,N):-Z = 0, A is First mod 10, B is First//30 , C is (First//10) mod 3,
															A==Player, B==C, diag(Game,Player,Z,M), N is M+1.
diag([First|Game],Player,Z,N):-Z = 0, A is First mod 10, not(A==Player), diag(Game,Player,Z,N).
diag([First|Game],Player,Z,N):-Z = 0, B is First//3, C is First mod 3, not(B==C), diag(Game,Player,Z,N).

diag([First|Game],Player,Z,N):-Z = 1, A is First mod 10, B is First//30 , C is 2-(First//10) mod 3,
															A==Player, B==C, diag(Game,Player,Z,M), N is M+1.
diag([First|Game],Player,Z,N):-Z = 1, A is First mod 10, not(A==Player), diag(Game,Player,Z,N).
diag([First|Game],Player,Z,N):-Z = 1, B is First//3, C is First mod 3, not(B==C), diag(Game,Player,Z,N).
